	- 정적 메소드 선언 시 주의할 점
		- 1. 메소드 내부에 인스턴스 필드나 인스턴스 메소드 사용 불가
		- 2. 객체 자신을 참조하는 this 키워드 사용 불가
		
	- 정적 메소드에서 인스턴스 멤버 사용하려는 경우
		- 객체 우선 생성 후 참조변수로 접근
		
	- main() 메소드는 정적 메소드이므로 동일 규칙 적용
	
- 싱글톤(singleton)
	- 전체 프로그램에서 단 하나의 객체만 만들도록 보장하는 코딩기법
	
	- 싱글톤 작성 방법
		- 1. 클래스 외부에서 new 연산자를 통해 생성자를 호출하는 것을 불가하도록 private 접근제한자 사용
		- 2. 자신의 타입인 정적 필드 선언 후 자신의 객체를 생성해 초기화
		- 3. 외부에서 호출할 수 있는 getInstance() 선언
		- 4. 정적 필드에서 참조하는 자신의 객체 리턴

- final 필드
	- 초기값이 저장되면 최종값이 되어 프로그램 실행 도중 수정 불가
	
	- final 필드의 초기값 주는 방법
		- 단순 값일 경우 : 필드 선언 시 초기화
		(ex. 정적필드(상수)일 경우)
		- 객체 생성 시 외부 데이터로 초기화가 필요한 경우 : 생성자에서 초기화
		(ex. 인스턴스 필드)

	- 인스턴스 final 필드
		- 객체에 한번 초기화 된 데이터를 변경 불가로 만들 경우
		(ex. 주민번호)
		
	- 정적 final 필드(관례적으로 모두 대문자로 작성해야 함)
		- 불변하는 값(상수)을 만들 경우
		(ex. PI)

- 패키지
	- 파일 시스템의 폴더
	-> 클래스를 유일하게 만들어주는 식별자 역할
	--> 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식
	
	- import문
		- 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속된 경우
		-> 해당 패키지 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에 통지
		--> 패키지 선언과 클래스 선언 사이에 작성
	(형태)
	import 상위패키지.하위패키지.클래스이름;
	// 사용하고자 하는 클래스들이 동일한 패키지 소속일 때
	->	import 상위패키지.하위패키지.*;
	
	// 패키지가 다른 클래스들의 이름이 같고 모두 import 되어있을 때
	-> 컴파일러가 어떤 패키지의 클래스를 쓰는 것인지 애매모호함 --> 컴파일에러
	=> import문과 상관없이 패키지가 포함된 클래스 전체 이름을 기술

- 접근 제한자(access modifier)
	- 접근을 제한하기 위해 사용
		- 클래스와 인터페이스 및 이들이 가진 멤버의 접근제한
		
		- public	: 외부 클래스가 자유롭게 사용할 수 있음
		- protected	: 같은 패키지 또는 자식 클래스에서만 사용할 수 있음
		- default	: 같은 패키지에 소속된 클래스만 사용 가능
		- private	: 외부에서 사용할 수 없음
		
		public, default : 클래스에 적용 가능
		protected, private : 클래스에 적용 불가
		
	(접근 제한 강화)
	public → protected → default → private
	
- 생성자의 접근 제한
	- 객체를 생성하기 위해서는 new 연산자로 생성자 호출
		-- 생성자를 어디서나 호출 가능한건 아님

- Getter, Setter 메소드
	- Setter 메소드
		- 외부의 값을 받아 필드의 값을 변경하는 것이 목적
		-- 매개값 검증하여 유효한 것만 필드로 저장 가능
		
	- Getter 메소드
		- 외부로 필드값을 전달하는 것이 목적
		-- 필드값을 가공해서 외부로 전달할 수 있음
	
	